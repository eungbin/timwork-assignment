# DESIGN

## 데이터 분석

각 공간들을 나열하고, 해당 공간들에 존재하는 공종들과, 각 공종들에 대한 정보를 나열했다고 생각합니다. 크게 `drawing(공간)`, drawing 아래에 `disciplines(공종)`, disciplines 아래에 `revisions(리비전)`, 일부 공종은 `regions(영역)`가 존재.


## 접근 방식

전체 과제는 '사용자 시나리오 분석 -> 데이터 해석 -> 사용자 흐름 설계 -> 구현' 순서로 진행했습니다. 

1. 사용자 시나리오 분석
- `README.md`에 작성된 과제의 최종 목표와 사용자 시나리오를 보며 현 상황에서 사용자가 겪을 수 있는 불편함은 무엇인지 분석하고, 사용자의 불편함을 어떻게 해소해줄 수 있을지 생각하였습니다.

2. 데이터 해석
- `metadata.json`을 계층별로 먼저 정리하고, 계층별 존재하는 데이터가 어떤 의미를 가지고 있는지 생각하는 시간을 가진 단계였습니다.
- 최종적으로 `drawing` -> `disciplines` -> `regions`(특정 경우에 존재) -> `revisions`로 정리되었고, 각 단계별로 존재하는 `polygon data`, `image overlay data`를 이해하기 위해 노력하였습니다.

3. 사용자 흐름 설계
- 1번의 사용자 시나리오 분석을 기준으로, 공간 선택 -> 공종 선택 -> (특정 경우)영역 선택 -> 리비전 선택 -> 비교할 공종 선택의 흐름을 잡았습니다
- UI에 이 흐름을 반영해 탐색 영역(왼쪽), 시각화 영역(중앙), 컨텍스트(오른쪽)로 분리했습니다.

4. 구현
- 위 내용들을 토대로 구현을 진행하였습니다.

## UI 설계 결정

1. UI 선택 근거
- UI는 탐색(왼쪽), 도면 시각화(중앙), 컨텍스트(오른쪽) 3개의 패널을 사용하는 레이아웃으로 설계했습니다.<br /> 이 구조를 사용한 이유는 사용자가 도면을 찾는 과정(공간-공종-영역-리비전 선택)과 선택한 결과에 따른 결과 확인(도면 및 오버레이), 그리고 현재 상태(경로 및 리비전 상세 정보)를 동시에 수행하고 한 눈에 볼 수 있어야 할 것 같다고 생각했기 때문입니다.<br /> 하나의 화면에서 입력과 해당 입력에 대한 출력(결과 화면), 설명까지 분리해서 보여주면 각각의 영역이 담당하는 역할이 명확해 인지 부하를 줄일 수 있다고 생각했습니다.
- 왼쪽 탐색 패널의 경우 공간을 선택할 때 사용자에게 두 가지 방식을 지원하였습니다.<br /> 텍스트 기반으로 검색이 가능한 dropdown list와 배치도를 기반으로 공간 polygon을 선택할 수 있도록 하여 텍스트 탐색과 공간적 탐색을 동시에 지원하였습니다.

2. 고려했던 다른 대안
- 현재 방법과는 정반대의 방법인 단일 패널 구조가 있었습니다.<br /> 해당 구조는 하나의 패널만 존재하기에 화면 밀도는 좋지만, 단계별로 화면이 전환되기에 사용자가 현재 경로를 계속 기억해야 하는 부담이 증가하게 되고, 빠른 탐색과 현재 상태를 한 눈에 파악하기 어려울 것 같다고 판단되어 채택하지 않았습니다.


## 기술 선택 근거

1. 상태 관리
- 전역 라이브러리를 사용하지 않고 React 기본 훅을 사용하였습니다.<br /> 화면 간 공유 상태보다 탐색 상태에서의 전이(공간->공종->리전->리비전)가 핵심이라고 생각되어, `reducer`로 전이 규칙을 명시하고 `selector`로 파생 계산을 분리하는 방식을 사용하는 것이 가장 단순하고 예측 가능하다고 생각하였습니다.<br /> 또한 뷰 전용 상태(검색 드롭다운, hover 등)는 컴포넌트/전용 훅으로 분리해 비즈니스 로직과 UI 상호작용 로직을 분리하도록 노력하였습니다.

2. 스타일링
- `Tailwind CSS`를 사용하였습니다.<br /> 사실... 스타일링에 관해서는 딱히 말씀드릴 것이 없는 것 같습니다. 요즘 자주 사용하는 ui 라이브러리를 채택하였습니다.

## 어려웠던 점 및 개선 방안

1. `Revision` 고민
- 비교 오버레이에서 어떤 리비전을 사용해야 할지가 첫 번째 고민이었습니다. <br />과제 시나리오의 공종 간 간섭 확인 목적을 기준으로, 오버레이 대상은 항상 최신 리비전을 사용하는 정책이 가장 실무 흐름에 맞다고 판단했습니다.<br /> 기준 도면(현재 선택한 리비전) 위에 타 공종의 최신 상태를 겹쳐 보는 방식이 실제 의사결정에 유리하다고 보았습니다.

2. `Region` 케이스에 대한 고민과 `imageTransform`
- 101동 구조 공종은 `Region A/B`로 분리되어 있어, 원본 구조 도면 위에 리전 리비전을 덮어 보여줄지, 리전 리비전만 단독으로 보여줄지
두 가지를 비교했습니다. <br />초기에는 원본+리전 오버레이 방식을 고려했지만, 최종적으로는 리전 단독 표시를 기본으로 선택했습니다. <br /> 이유는 리전별 변경 비교를 더 명확하게 보여주고, 그 위에 다른 공종을 오버레이해도 간섭 확인이 가능했기 때문입니다.<br />
- 위 문제를 고민하는 과정에서 한 가지를 더 발견했습니다. <br />위 방식대로 개발을 진행해보니 같은 `Region` 안의 리비전인데도 `imageTransform` 값이 서로 달랐습니다. <br />저는 동일한 `Region` 내 리비전은 이미지의 위치, 크기, 회전 값이 유사해야 한다고 예상했는데, 실제 `metadata.json` 값은 차이가 있었습니다. <br />코드를 변경해 다른 공종 도면과 오버레이하며 비교해본 결과, REV1 계열의 `imageTransform` 값이 상대적으로 정합이 더 잘 맞는다고 판단했습니다.<br />그래서 실험적으로 `metadata.json`의 일부 값을 아래처럼 조정했습니다. (이 방식이 정답인지는 확신하지 못한 상태입니다.)

3. 오버레이 `imageTransform`
- 기존 도면에 비교를 위한 오버레이 도면을 추가할 때, `metadata.json`의 `imageTransform`의 정보를 읽어와서 오버레이 도면을 추가하는 작업을 진행했습니다. 이 작업을 진행하는 도중 A 도면 위에 B 도면을 올렸을 때, `[x, y]` 좌표 혹은 `scale`이 조금씩 달라 도면이 정확하게 겹쳐지지 않는 문제가 발생하였습니다.<br /> 제가 데이터 구조를 잘못 이해한 것인지, 계산 로직을 잘못 작성한 것인지 확실하게 구분하기 어렵지만 시간이 없어 해결하지 못하였습니다.
